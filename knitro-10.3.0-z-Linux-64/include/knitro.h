/*******************************************************/
/* Copyright (c) 2017 by Artelys                       */
/* All Rights Reserved                                 */
/*******************************************************/

/* Artelys Knitro 10.3.0 application interface header file. */

#ifndef KNITRO_H__
#define KNITRO_H__

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

#include <stddef.h>

/*------------------------------------------------------------------*/
/*     EXPORT MACROS                                                */
/*------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WIN32
  #ifdef MAKE_KNITRO_DLL
    #define KNITRO_API __declspec(dllexport) __stdcall
  #else
    #define KNITRO_API __stdcall
  #endif
#else
  #if __GNUC__ >= 4
    #define KNITRO_API __attribute__ ((visibility ("default")))
  #else
    #define KNITRO_API
  #endif
#endif


/*------------------------------------------------------------------*/
/*     FORWARD DECLARATION TYPE DEFINITIONS                         */
/*------------------------------------------------------------------*/

/** Type declaration for the Knitro solver context object.
 *  All methods pass a pointer to the solver.
 *  Applications must not modify any part of the solver context,
 *  except by making Knitro API calls.
 */
typedef struct KTR_context KTR_context, *KTR_context_ptr;

/** Type declaration for the Ziena License Manager context object.
 *  Applications must not modify any part of the context.
 */
typedef struct ZLM_context ZLM_context, *ZLM_context_ptr;

/** Type declaration for the callback that allows applications to handle
 *  output.  The function should return the number of characters that
 *  were printed.  See KTR_set_puts_callback for more information.
 */
typedef int  KTR_puts (const char * const  str,
                             void * const  userParams);


/*------------------------------------------------------------------*/
/*     FUNCTION DECLARATIONS                                        */
/*------------------------------------------------------------------*/

    
/* -----  Creating and destroying solver objects ----- */

/** Call KTR_new or KTR_new_puts first.  Either returns a pointer to the
 *  solver object that is used in all other Knitro API calls.
 *  A new Knitro license is acquired and held until KTR_free has been called,
 *  or until the calling program ends.
 *  Returns NULL on error.
 */
KTR_context_ptr  KNITRO_API KTR_new (void);

/** Call KTR_new or KTR_new_puts first.  Either returns a pointer to the
 *  solver object that is used in all other Knitro API calls.
 *  A new Knitro license is acquired and held until KTR_free has been called,
 *  or until the calling program ends.
 *  This function also takes an argument that sets a "put string" callback
 *  function to handle output generated by the Knitro solver, and a pointer
 *  for passing user-defined data.  See KTR_set_puts_callback for more
 *  information.
 *  Returns NULL on error.
 */
KTR_context_ptr  KNITRO_API KTR_new_puts (KTR_puts * const  fnPtr,
                                          void     * const  userParams);

/** Free all memory and release any Knitro license acquired by calling
 *  KTR_new or KTR_new_puts.  The address of the pointer is set to NULL
 *  after freeing memory, to help avoid mistakes.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_free (KTR_context_ptr *  kc_handle);


/* -----  Creating and destroying solvers in high volume ----- */

/** High volume applications construct new Knitro instances repeatedly,
 *  each lasting only a short time.  Special functions allow a single
 *  license to be checked out once for a sequence of Knitro instances.
 *  Reusing a license saves time in the Knitro solver, and improves the
 *  performance of the Ziena License Manager server.
 *
 *  The typical calling sequence is:
 *    ZLM_checkout_license
 *      KTR_new_zlm
 *        KTR_init_problem
 *        KTR_solve (a single call, or a reverse communications loop)
 *      KTR_free
 *      KTR_new_zlm
 *        KTR_init_problem
 *        KTR_solve (a single call, or a reverse communications loop)
 *      KTR_free
 *      ...
 *    ZLM_release_license
 *
 *  High volume functions are not available in the "student" version.
 *  Please see the Ziena License Manager user manual for more information.
 */

/** Allocate memory for a license from the Ziena License Manager for high
 *  volume Knitro applications.  The license will be checked out the first
 *  time KTR_new_zlm is called.  The license must be checked in later by
 *  calling ZLM_release_license.
 *  Returns NULL on error.
 */
ZLM_context_ptr  KNITRO_API ZLM_checkout_license (void);

/** Returns a pointer to the solver object that is used in all other Knitro
 *  API calls.  Pass the license acquired by calling ZLM_checkout_license.
 *  This function also takes an argument that sets a "put string" callback
 *  function to handle output generated by the Knitro solver, and a pointer
 *  for passing user-defined data.  See KTR_set_puts_callback for more
 *  information.
 *  Returns NULL on error.
 */
KTR_context_ptr  KNITRO_API KTR_new_zlm (KTR_puts    * const  fnPtr,
                                         void        * const  userParams,
                                         ZLM_context * const  pZLMcontext);

/** Release the Knitro license and free allocated memory.
 *  Knitro will set the address of the pointer to NULL after freeing
 *  memory, to help avoid mistakes.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API ZLM_release_license (ZLM_context *  pZLMcontext);


/* ----- Changing and reading solver parameters ----- */

/** Parameters cannot be set after Knitro begins solving; ie, after
 *  the KTR_solve function is called.  They may be set again after
 *  calling KTR_restart.
 *    All methods return 0 if OK, nonzero if there was an error.
 *  In most cases, parameter values are not validated until
 *  KTR_init_problem or KTR_solve is called.
 */

/** Reset all parameters to default values.
 */
int  KNITRO_API KTR_reset_params_to_defaults (KTR_context_ptr  kc);


/** Set all parameters specified in the given file. */
int  KNITRO_API KTR_load_param_file
    (KTR_context_ptr  kc, const char * const  filename);

/** Write all current parameter values to a file. */
int  KNITRO_API KTR_save_param_file
    (KTR_context_ptr  kc, const char * const  filename);

/** Set a parameter using its string name. */
int  KNITRO_API KTR_set_int_param_by_name
    (KTR_context_ptr  kc, const char * const  name, const int  value);
int  KNITRO_API KTR_set_char_param_by_name
    (KTR_context_ptr  kc, const char * const  name, const char * const  value);
int  KNITRO_API KTR_set_double_param_by_name
    (KTR_context_ptr  kc, const char * const  name, const double  value);
/** Set an integer or double parameter by name. */
int  KNITRO_API KTR_set_param_by_name
    (KTR_context_ptr  kc, const char * const  name, const double  value); 

/** Set a parameter using its integer identifier KTR_PARAM_x (defined below). */
int  KNITRO_API KTR_set_int_param
    (KTR_context_ptr  kc, const int  param_id, const int  value);
int  KNITRO_API KTR_set_char_param
    (KTR_context_ptr  kc, const int  param_id, const char * const  value);
int  KNITRO_API KTR_set_double_param
    (KTR_context_ptr  kc, const int  param_id, const double  value);

/** Get a parameter using its string name. */
int  KNITRO_API KTR_get_int_param_by_name
    (KTR_context_ptr  kc, const char * const  name, int * const  value);
int  KNITRO_API KTR_get_double_param_by_name
    (KTR_context_ptr  kc, const char * const  name, double * const  value);

/** Get a parameter using its integer identifier KTR_PARAM_x (defined below). */
int  KNITRO_API KTR_get_int_param
    (KTR_context_ptr  kc, const int  param_id, int * const  value);
int  KNITRO_API KTR_get_double_param
    (KTR_context_ptr  kc, const int  param_id, double * const  value);

/** Sets the string param_name with the name of parameter indexed by
 *  param_id and returns 0. Returns an error if param_id does not 
 *  correspond to any parameter, or if the parameter output_size 
 *  (the size of char array param_name) is less than the size of the 
 *  parameter's description.
 */
int KNITRO_API KTR_get_param_name(      KTR_context_ptr kc,
                                  const int             param_id, 
                                        char * const    param_name, 
                                  const size_t          output_size);

/** Sets the string description with the description of the parameter
 *  indexed by param_id and its possible values and returns 0. Returns an
 *  error if param_id does not correspond to any parameter, or if the
 *  parameter output_size (the size of char array description) is less than
 *  the size of the parameter's description.
 */
int KNITRO_API KTR_get_param_doc(      KTR_context_ptr kc,
                                 const int             param_id, 
                                       char * const    description,
                                 const size_t          output_size);

/** Sets the int * param_type to the parameter type of parameter indexed
 *  by param_id. Possible values are KTR_PARAMTYPE_INTEGER, KTR_PARAMTYPE_FLOAT,
 *  KTR_PARAMTYPE_STRING. Returns an error if param_id does not correspond to 
 *  any parameter.
 */
int KNITRO_API KTR_get_param_type(      KTR_context_ptr kc,
                                  const int             param_id, 
                                        int * const     param_type);

/** Set the int * num_param_values to the number of possible parameter
 *  values for parameter indexed by param_id and returns 0. If there is
 *  not a finite number of possible values, num_param_values will be zero.
 *  Returns an error if param_id does not correspond to any parameter.
 */
int KNITRO_API KTR_get_num_param_values(      KTR_context_ptr kc,
                                        const int             param_id, 
                                              int * const     num_param_values);

/** Set string param_value_string to the description of parameter value
 *  indexed by [param_id][value_id]. Returns an error if param_id does not
 *  correspond to any parameter, or if value_id is greater than the number
 *  of possible parameter values, or if there are not a finite number of 
 *  possible parameter values, or if the parameter output_size (the size 
 *  of char array param_value_string) is less than the size of the 
 *  parameter's description.
 */
int KNITRO_API KTR_get_param_value_doc(      KTR_context_ptr kc,
                                       const int             param_id, 
                                       const int             value_id, 
                                             char * const    param_value_string, 
                                       const size_t          output_size);

/** Gets the integer value corresponding to the parameter name input and 
 *  copies it into param_id input. Returns zero if successful and an error
 *  code otherwise.
 */
int KNITRO_API KTR_get_param_id(      KTR_context_ptr kc,
                                const char * const    name,
                                      int  * const    param_id);
    
/** Similar to KTR_load_param_file but specifically allows user to
 *  specify a file of options (and option values) to explore for
 *  the Knitro-Tuner.
 */
int  KNITRO_API KTR_load_tuner_file
    (KTR_context_ptr  kc, const char * const  filename);

/** Copy the Knitro release name into "release".  This variable must be
 *  preallocated to have "length" elements, including the string termination
 *  character.  For compatibility with future releases, please allocate at
 *  least 15 characters. */
void  KNITRO_API KTR_get_release
    (const int  length, char * const  release);

/** Set an array of absolute feasibility tolerances (one for each
 *  constraint and variable) to use for the termination tests.
 *  The user options KTR_PARAM_FEASTOL/KTR_PARAM_FEASTOLABS define
 *  a single tolerance that is applied equally to every constraint
 *  and variable.  This API function allows the user to specify
 *  separate feasibility termination tolerances for each constraint
 *  and variable.  Values specified through this function will override
 *  the value determined by KTR_PARAM_FEASTOL/KTR_PARAM_FEASTOLABS. The
 *  tolerances should be positive values.  If a non-positive value is
 *  specified, that constraint or variable will use the standard tolerances
 *  based on  KTR_PARAM_FEASTOL/KTR_PARAM_FEASTOLABS.
 *  Array cFeasTols has length m, array xFeasTols has length n, and
 *  array ccFeasTols has length ncc, where ncc is the number of
 *  complementarity constraints added through KTR_set_compcons().
 *  The regular constraints are considered to be satisfied when
 *      c[i] - cUpBnds[i] <= cFeasTols[i]  for all i=1..m, and
 *      cLoBnds[i] - c[i] <= cFeasTols[i]  for all i=1..m
 *  The variables are considered to be satisfied when
 *      x[i] - xUpBnds[i] <= xFeasTols[i]  for all i=1..n, and
 *      xLoBnds[i] - x[i] <= xFeasTols[i]  for all i=1..n
 *  The complementarity constraints are considered to be satisfied when
 *      min(x1_i, x2_i) <= ccFeasTols[i]  for all i=1..ncc,
 *  where x1 and x2 are the arrays of complementary pairs.
 *  If there are no regular (or complementarity) constraints set
 *  cFeasTols=NULL (or ccFeasTols=NULL).  If
 *  cFeasTols/xFeasTols/ccFeasTols=NULL, then the standard tolerances will
 *  be used.  Knitro makes a local copy of all inputs, so the application
 *  may free memory after the call.
 *  This routine must be called after calling KTR_init_problem /
 *  KTR_lsq_init_problem / KTR_mip_init_problem and after any calls
 *  to KTR_set_compcons.  It must be called before calling
 *  KTR_solve / KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_set_feastols
    (      KTR_context_ptr kc,
     const double * const  cFeasTols,
     const double * const  xFeasTols,
     const double * const  ccFeasTols);

/** Set an array of variable scaling and centering values (one for
 *  each variable) to perform a linear scaling
 *    x[i] = xScaleFactors[i] * xScaled[i] + xScaleCenters[i]  
 *  for each variable. These scaling factors should try to
 *  represent the "typical" values of the "x" variables so that the
 *  scaled variables ("xScaled") used internally by Knitro are close
 *  to one.  The values for xScaleFactors should be positive.
 *  If a non-positive value is specified, that variable will not
 *  be scaled.
 *  This routine must be called after calling KTR_init_problem /
 *  KTR_lsq_init_problem / KTR_mip_init_problem and before
 *  calling KTR_solve / KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_set_var_scalings
    (      KTR_context_ptr kc,
     const double * const  xScaleFactors,
     const double * const  xScaleCenters);


/** Set an array of constraint scaling values (one for
 *  each constraint) to perform a scaling
 *    cScaled[i] = cScaleFactors[i] * c[i]  
 *  for each constraint. These scaling factors should try to
 *  represent the "typical" values of the inverse of the constraint
 *  values "c" so that the scaled constraints ("cScaled") used
 *  internally by Knitro are close to one.  Scaling factors for
 *  standard constraints can be provided with "cScaleFactors", while
 *  scalings for complementarity constraints can be specified with
 *  "ccScaleFactors".  The values for cScaleFactors/ccScaleFactors
 *  should be positive.  If a non-positive value is specified, that
 *  constraint will use either the standard Knitro scaling
 *  (KTR_SCALE_USER_INTERNAL), or no scaling (KTR_SCALE_USER_NONE).
 *  This routine must be called after calling KTR_init_problem /
 *  KTR_lsq_init_problem / KTR_mip_init_problem and before
 *  calling KTR_solve / KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_set_con_scalings
    (      KTR_context_ptr kc,
     const double * const  cScaleFactors,
     const double * const  ccScaleFactors);

/** Set a scaling value for the objective function
 *    objScaled = objScaleFactor * obj  
 *  This scaling factor should try to represent the "typical"
 *  value of the inverse of the objective function value "obj" so
 *  that the scaled objective ("objScaled") used internally by
 *  Knitro is close to one. The value for objScaleFactor
 *  should be positive.  If a non-positive value is specified, then
 *  the objective will use either the standard Knitro scaling
 *  (KTR_SCALE_USER_INTERNAL), or no scaling (KTR_SCALE_USER_NONE). 
 *  This routine must be called after calling KTR_init_problem /
 *  KTR_lsq_init_problem / KTR_mip_init_problem and before
 *  calling KTR_solve / KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_set_obj_scaling
    (      KTR_context_ptr kc,
     const double          objScaleFactor);

    
/** Set names for model components passed in by the user/modeling
 *  language so that Knitro can internally print out these names.
 *  Knitro makes a local copy of all inputs, so the application may
 *  free memory after the call.
 *  This routine must be called after calling KTR_init_problem /
 *  KTR_lsq_init_problem / KTR_mip_init_problem and before
 *  calling KTR_solve / KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_set_names
    (      KTR_context_ptr kc,
     const char   * const  objName,
           char   * const  varNames[],
           char   * const  conNames[]);
    
/** This API function can be used to identify which variables only
 *  appear linearly in the model (KTR_LINEARVAR_YES).  This information
 *  can be used by Knitro to perform more extensive preprocessing. If a
 *  variable appears nonlinearly in any constraint or the objective (or
 *  if the user does not know) then it should be marked as
 *  KTR_LINEARVAR_NO. Array linearVars has length n. Knitro makes a
 *  local copy of all inputs, so the application may free memory after
 *  the call.
 *  This routine must be called after calling KTR_init_problem /
 *  KTR_lsq_init_problem / KTR_mip_init_problem and before
 *  calling KTR_solve / KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_set_linearvars
    (      KTR_context_ptr kc,
     const int    * const  linearVars);

/** This API function can be used to identify which variables 
 *  should satisfy their variable bounds throughout the optimization
 *  process (KTR_HONORBNDS_ALWAYS).  The user option KTR_PARAM_HONORBNDS
 *  can be used to set ALL variables to honor their bounds.  This
 *  routine takes precedence over the setting of KTR_PARAM_HONORBNDS
 *  and is used to customize the settings for individual variables.
 *  Knitro makes a local copy of all inputs, so the application may
 *  free memory after the call.
 *  This routine must be called after calling KTR_init_problem /
 *  KTR_lsq_init_problem / KTR_mip_init_problem and before
 *  calling KTR_solve / KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_set_honorbnds
    (      KTR_context_ptr kc,
     const int    * const  honorBnds);
    
    
/* ----- Problem modification ----- */

/** This function adds complementarity constraints to the problem.
 *  It must be called after KTR_init_problem and before KTR_solve.
 *  The two lists are of equal length, and contain matching pairs of
 *  variable indices.  Each pair defines a complementarity constraint
 *  between the two variables.  The function can only be called once to
 *  set all the complementarity constraints in the model at one time.
 *
 *  Returns 0 if OK, or a negative value on error.
 */
int  KNITRO_API KTR_set_compcons (KTR_context_ptr    kc,
                                  const int          numCompConstraints,
                                  const int * const  indexList1,
                                  const int * const  indexList2);    
/** An older version of a function for adding complementarity constraints
 *  maintained for backwards compatibility. Please use the newer version
 *  defined above. */    
int  KNITRO_API KTR_addcompcons (KTR_context_ptr    kc,
                                 const int          numCompConstraints,
                                 const int * const  indexList1,
                                 const int * const  indexList2);

/** Prepare Knitro to re-optimize the current problem after
 *  modifying the variable bounds from a previous solve.
 *  It must be called after KTR_init_problem and precedes a call
 *  to KTR_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_chgvarbnds (      KTR_context_ptr          kc,
                                const double          * const  xLoBnds,
                                const double          * const  xUpBnds);


/* ----- Solving ----- */

/** Problem structure is passed to Knitro using KTR_init_problem.
 *    The problem is solved by calling KTR_solve.  Applications must
 *  provide a means of evaluating the nonlinear objective, constraints,
 *  first derivatives, and (optionally) second derivatives.  (First
 *  derivatives are also optional, but highly recommended.)
 *    If the application provides callback functions for making evaluations
 *  (see KTR_callback below), then a single call to KTR_solve will return
 *  the solution.  Alternatively, the application can employ a reverse
 *  communications driver.  In this case, KTR_solve returns a status code
 *  whenever it needs evaluation data (see examples/C/reverseCommExample.c).
 *
 *  The typical calling sequence is:
 *    KTR_new
 *    KTR_init_problem
 *    KTR_set_xxx_param (set any number of parameters)
 *    KTR_solve (a single call, or a reverse communications loop)
 *    KTR_free
 *
 *  Calling sequence if the same problem is to be solved again,
 *  with different parameters or a different start point:
 *    KTR_new
 *    KTR_init_problem
 *    KTR_set_xxx_param (set any number of parameters)
 *    KTR_solve (a single call, or a reverse communications loop)
 *    KTR_restart
 *    KTR_set_xxx_param (set any number of parameters)
 *    KTR_solve (a single call, or a reverse communications loop)
 *    KTR_free
 *
 *  For MIP problems, use KTR_mip_init_problem and KTR_mip_solve
 *  instead of KTR_init_problem and KTR_solve.
 */

/** Initialize Knitro with a new problem.  Knitro makes a local copy of
 *  all inputs, so the application may free memory after the call
 *  completes.  Arrays cannot be NULL, except as follows:
 *  - If "xLoBnds" or "xUpBnds" are NULL, then Knitro assumes all variables
 *    are unbounded in that direction.
 *  - If the application does not supply an exact Hessian, then pass nnzH=0
 *    and NULL pointers for "hessIndexRows" and "hessIndexCols".
 *  - If "xInitial" or "lambdaInitial" are NULL, then Knitro determines the
 *    initial start point.
 *  If a particular bound does not exist, then load the array element
 *  with KTR_INFBOUND for an upper bound, or -KTR_INFBOUND for a lower bound.
 *  Knitro interprets this value as infinity and ignores the bound.
 *    To make the j-th constraint be an equality constraint, set cLoBnds[j]
 *  equal to cUpBnds[j].
 *
 *  Returns 0 if OK, nonzero if error.
 *
 *  Brief description of the arguments (consult the Knitro manual for details):
 *    n             - number of unknowns
 *    objGoal       - objective goal (KTR_OBJGOAL_MINIMIZE or _MAXIMIZE)
 *    objType       - objective type (eg, KTR_OBJTYPE_GENERAL)
 *    xLoBnds       - (length n) lower bounds on the variables
 *    xUpBnds       - (length n) upper bounds on the variables
 *    m             - number of constraints
 *    cType         - (length m) constraint type (eg, KTR_CONTYPE_GENERAL)
 *    cLoBnds       - (length m) lower bounds on the constraints
 *    cUpBnds       - (length m) upper bounds on the constraints
 *    nnzJ          - number of nonzeroes in the sparse constraint Jacobian
 *    jacIndexVars  - (length nnzJ) variable index (column) of each nonzero
 *    jacIndexCons  - (length nnzJ) constraint index (row) of each nonzero
 *    nnzH          - number of nonzeroes in the sparse Hessian of Lagrangian
 *    hessIndexRows - (length nnzH) row index of each nonzero
 *    hessIndexCols - (length nnzH) column index of each nonzero
 *    xInitial      - (length n) initial start point for the unknowns
 *    lambdaInitial - (length m+n) initial start point for multipliers
 */
int  KNITRO_API KTR_init_problem (KTR_context_ptr       kc,
                                  const int             n,
                                  const int             objGoal,
                                  const int             objType,
                                  const double * const  xLoBnds,
                                  const double * const  xUpBnds,
                                  const int             m,
                                  const int    * const  cType,
                                  const double * const  cLoBnds,
                                  const double * const  cUpBnds,
                                  const int             nnzJ,
                                  const int    * const  jacIndexVars,
                                  const int    * const  jacIndexCons,
                                  const int             nnzH,
                                  const int    * const  hessIndexRows,
                                  const int    * const  hessIndexCols,
                                  const double * const  xInitial,
                                  const double * const  lambdaInitial);

                                  
/** Initialize Knitro with a new problem.  Knitro makes a local copy of
 *  all inputs, so the application may free memory after the call
 *  completes.  Arrays cannot be NULL, except as follows:
 *  - If "xLoBnds" or "xUpBnds" are NULL, then Knitro assumes all variables
 *    are unbounded in that direction.
 *  - If "xInitial" or "lambdaInitial" are NULL, then Knitro determines the
 *    initial start point.
 *  If a particular bound does not exist, then load the array element
 *  with KTR_INFBOUND for an upper bound, or -KTR_INFBOUND for a lower bound.
 *  Knitro interprets this value as infinity and ignores the bound.
 *    To make the j-th constraint be an equality constraint, set cLoBnds[j]
 *  equal to cUpBnds[j].
 *
 *  Returns 0 if OK, nonzero if error.
 *
 * Brief description of the arguments (consult the Knitro manual for details):
 *    n             - number of variables
 *    xLoBnds       - vector of lower bounds on variables
 *    xUpBnds       - vector of upper bounds on variables
 *    m             - number of residuals
 *    rType         - residuals type (KTR_RESTYPE_GENERAL or KTR_RESTYPE_LINEAR)
 *    nnzJ          - number of nonzero elements in jacobian of residuals
 *    jacIndexVars  - column indices of nonzero elements of jacobian
 *    jacIndexRes   - row indices of nonzero elements of jacobian
 *    xInitial      - vector of initial guesses on variables
 *    lambdaInitial - vector of initial guesses on duals associated to bound constraints
 */
int KNITRO_API KTR_lsq_init_problem(KTR_context_ptr      kc,
                                    const int            n,
                                    const double * const xLoBnds,
                                    const double * const xUpBnds,
                                    const int            m,
                                    const int * const    rType,
                                    const int            nnzJ,
                                    const int * const    jacIndexVars,
                                    const int * const    jacIndexRes,
                                    const double * const xInitial,
                                    const double * const lambdaInitial);
                                  
                                  
/** Call Knitro to solve the problem.  If the application provides callback
 *  functions for evaluating the function, constraints, and derivatives,
 *  then a single call to KTR_solve returns the solution.  Otherwise,
 *  Knitro operates in reverse communications mode and returns a status code
 *  that may request another call.  See the Knitro manual for details.
 *
 *  Returns one of the status codes KTR_RC_* (see definitions in this file).
 *  In particular:
 *    <0 - Knitro terminated with a fatal error
 *     0 - Knitro is finished: x, lambda, and obj contain the optimal solution
 *     1 - call KTR_solve again (reverse comm) with obj and c containing
 *         the objective and constraints evaluated at x
 *     2 - call KTR_solve again (reverse comm) with objGrad and jac containing
 *         the objective and constraint first derivatives evaluated at x
 *     3 - call KTR_solve again (reverse comm) with hess containing
 *         H(x,lambda), the Hessian of the Lagrangian evaluated at x and lambda
 *     7 - call KTR_solve again (reverse comm) with hessVector containing
 *         the result of H(x,lambda) * hessVector
 *
 *  Brief description of the arguments (consult the Knitro manual for details):
 *    x          - output (length n) solution point estimate
 *    lambda     - output (length m+n) Lagrange multiplier estimate
 *    evalStatus - input  evaluation status (0=OK)
 *    obj        - input  (length 1) objective at x
 *                 output            optimal objective when finished
 *    c          - input  (length m) constraints at x
 *    objGrad    - input  (length n) objective gradient at x
 *    jac        - input  (length nnzJ) sparse constraint gradient at x
 *    hess       - input  (length nnzH) sparse Hessian at x and lambda
 *    hessVector - input  (length n) result of H(x,lambda) * hessVector
 *                 output            vector to multiply Hessian by
 *    userParams - input  passed directly to application callback functions
 *
 *  If "gradopt" is set to compute finite differences for first derivatives,
 *  then KTR_solve will modify objGrad and jac; otherwise, these arguments
 *  are not modified.
 */
int  KNITRO_API KTR_solve ( KTR_context_ptr      kc,
                                 double * const  x,
                                 double * const  lambda,
                           const int             evalStatus,
                                 double * const  obj,
                           const double * const  c,
                                 double * const  objGrad,
                                 double * const  jac,
                           const double * const  hess,
                                 double * const  hessVector,
                                 void   * const  userParams);


/** Prepare Knitro to restart the current problem at a new start point.
 *  If output to a file is enabled, this will erase the current file.
 *  Knitro parameter values are not changed by this call.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_restart (KTR_context_ptr       kc,
                             const double * const  xInitial,
                             const double * const  lambdaInitial);

/** For MIP problems, use KTR_mip_init_problem and KTR_mip_solve
 *  instead of KTR_init_problem and KTR_solve.
 */

/** Initialize Knitro with a new MIP problem.  Knitro makes a local copy of
 *  all inputs, so the application may free memory after the call
 *  completes.  Arrays cannot be NULL, except as follows:
 *  - If "xLoBnds" or "xUpBnds" are NULL, then Knitro assumes all continuous
 *    variables are unbounded in that direction.
 *  - If "yLoBnds" or "yUpBnds" are NULL, then Knitro assumes all integer
 *    variables are unbounded in that direction.
 *  - If the application does not supply an exact Hessian, then pass nnzH=0
 *    and NULL pointers for "hessIndexRows" and "hessIndexCols".
 *  - If "xInitial" or "lambdaInitial" are NULL, then Knitro determines the
 *    initial start point.
 *  If a particular bound does not exist, then load the array element
 *  with KTR_INFBOUND for an upper bound, or -KTR_INFBOUND for a lower bound.
 *  Knitro interprets this value as infinity and ignores the bound.
 *    To make the j-th constraint be an equality constraint, set cLoBnds[j]
 *  equal to cUpBnds[j].
 *
 *  Returns 0 if OK, nonzero if error.
 *
 *  Brief description of the arguments (consult the Knitro manual for details):
 *    n             - number of unknowns (continuous and integer)
 *    objGoal       - objective goal (KTR_OBJGOAL_MINIMIZE or _MAXIMIZE)
 *    objType       - objective type (eg, KTR_OBJTYPE_GENERAL)
 *    objFnType     - objective function type (eg, KTR_FNTYPE_CONVEX)
 *    xType         - (length n) variable type (eg, KTR_VARTYPE_INTEGER)
 *    xLoBnds       - (length n) lower bounds on the variables
 *    xUpBnds       - (length n) upper bounds on the variables
 *    m             - number of constraints
 *    cType         - (length m) constraint type (eg, KTR_CONTYPE_GENERAL)
 *    cFnType       - (length m) constraint function type (eg, KTR_FNTYPE_CONVEX)
 *    cLoBnds       - (length m) lower bounds on the constraints
 *    cUpBnds       - (length m) upper bounds on the constraints
 *    nnzJ          - number of nonzeroes in the sparse constraint Jacobian
 *    jacIndexVars  - (length nnzJ) variable index (column) of each nonzero
 *    jacIndexCons  - (length nnzJ) constraint index (row) of each nonzero
 *    nnzH          - number of nonzeroes in the sparse Hessian of Lagrangian
 *    hessIndexRows - (length nnzH) row index of each nonzero
 *    hessIndexCols - (length nnzH) column index of each nonzero
 *    xInitial      - (length n) initial start point for the unknowns
 *    lambdaInitial - (length m+n) initial start point for multipliers
 */
int  KNITRO_API KTR_mip_init_problem
    (      KTR_context_ptr kc,
     const int             n,
     const int             objGoal,
     const int             objType,
     const int             objFnType,
     const int    * const  xType,
     const double * const  xLoBnds,
     const double * const  xUpBnds,
     const int             m,
     const int    * const  cType,
     const int    * const  cFnType,
     const double * const  cLoBnds,
     const double * const  cUpBnds,
     const int             nnzJ,
     const int    * const  jacIndexVars,
     const int    * const  jacIndexCons,
     const int             nnzH,
     const int    * const  hessIndexRows,
     const int    * const  hessIndexCols,
     const double * const  xInitial,
     const double * const  lambdaInitial);


/** Set the branching priorities for integer variables.
 *  Priorities must be positive numbers (variables with non-positive values
 *  are ignored).  Variables with higher priority values will be considered
 *  for branching before variables with lower priority values.  When
 *  priorities for a subset of variables are equal, the branching rule is
 *  applied as a tiebreaker.
 *  Array xPriorities has length n, and values for continuous variables are
 *  ignored.  Knitro makes a local copy of all inputs, so the application
 *  may free memory after the call.
 *  This routine must be called after calling KTR_mip_init_problem and
 *  before calling KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_mip_set_branching_priorities
    (      KTR_context_ptr kc,
     const int * const     xPriorities);

/** Set strategies for dealing with individual integer variables. Possible
 *  strategy values include:
 *    KTR_MIP_INTVAR_STRATEGY_NONE    0 (default)
 *    KTR_MIP_INTVAR_STRATEGY_RELAX   1
 *    KTR_MIP_INTVAR_STRATEGY_MPEC    2 (binary variables only)    
 *  xIndex should be an index value corresponding to an integer variable
 *  (nothing is done if the index value corresponds to a continuous variable),
 *  and xStrategy should correspond to one of the strategy values listed above.
 *  This routine must be called after calling KTR_mip_init_problem and
 *  before calling KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_mip_set_intvar_strategy
    (      KTR_context_ptr kc,
     const int             xIndex,
     const int             xStrategy);

/** Call Knitro to solve the MIP problem.  If the application provides callback
 *  functions for evaluating the function, constraints, and derivatives,
 *  then a single call to KTR_mip_solve returns the solution.  Otherwise,
 *  Knitro operates in reverse communications mode and returns a status code
 *  that may request another call.  See the Knitro manual for details.
 *
 *  Returns one of the status codes KTR_RC_* (see definitions in this file).
 *  In particular:
 *    <0 - Knitro terminated with a fatal error
 *     0 - Knitro is finished: x, lambda, and obj contain the optimal solution
 *     1 - call KTR_mip_solve again (reverse comm) with obj and c containing
 *         the objective and constraints evaluated at x
 *     2 - call KTR_mip_solve again (reverse comm) with objGrad and jac
 *         containing the objective and constraint first derivatives evaluated
 *         at x
 *     3 - call KTR_mip_solve again (reverse comm) with hess containing
 *         H(x,lambda), the Hessian of the Lagrangian evaluated at x and lambda
 *     7 - call KTR_mip_solve again (reverse comm) with hessVector containing
 *         the result of H(x,lambda) * hessVector
 *
 *  Brief description of the arguments (consult the Knitro manual for details):
 *    x          - output (length n) solution point estimate
 *    lambda     - output (length m+n) Lagrange multiplier estimate
 *    evalStatus - input  evaluation status (0=OK)
 *    obj        - input  (length 1) objective at x
 *                 output            optimal objective if KTR_RC_BEGINEND
 *    c          - input  (length m) constraints at x
 *    objGrad    - input  (length n) objective gradient at x
 *    jac        - input  (length nnzJ) sparse constraint gradient at x
 *    hess       - input  (length nnzH) sparse Hessian at x and lambda
 *    hessVector - input  (length n) vector to multiply Hessian by
 *                 output            result of H(x,lambda) * hessVector
 *    userParams - input  passed directly to application callback functions
 *
 *  If "gradopt" is set to compute finite differences for first derivatives,
 *  then KTR_mip_solve will modify objGrad and jac; otherwise, these arguments
 *  are not modified.
 */
int  KNITRO_API KTR_mip_solve
    (      KTR_context_ptr kc,
           double * const  x,
           double * const  lambda,
     const int             evalStatus,
           double * const  obj,
           double * const  c,
           double * const  objGrad,
           double * const  jac,
           double * const  hess,
           double * const  hessVector,
           void   * const  userParams);


/** Set an array of relative stepsizes to use for the finite-difference
 *  gradient/Jacobian computations when using finite-difference
 *  first derivatives.  Finite-difference step sizes "delta" in Knitro are
 *  computed as:
 *       delta[i] = relStepSizes[i]*max(abs(x[i]),1);
 *  The default relative step sizes for each component of "x" are sqrt(eps)
 *  for forward finite differences, and eps^(1/3) for central finite
 *  differences.  Use this function to overwrite the default values.
 *  Array relStepSizes has length n.  Any zero values will use Knitro
 *  default values, while non-zero values will overwrite default values. If
 *  relStepSizes is set to NULL, then default Knitro values will be used.
 *  Knitro makes a local copy of all inputs, so the application may free
 *  memory after the call.  This routine must be called after calling
 *  KTR_init_problem and before calling KTR_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_set_findiff_relstepsizes
    (      KTR_context_ptr kc,
     const double * const  relStepSizes);


/* ----- Callbacks ----- */

/** Applications may define functions for evaluating problem elements
 *  at a trial point.  The functions must match the prototype defined
 *  below, and passed to Knitro with the appropriate KTR_set_func_x call.
 *  Knitro may request four different types of evaluation information,
 *  as specified in "evalRequestCode":
 *    KTR_RC_EVALFC - return objective and constraint function values
 *    KTR_RC_EVALGA - return first derivative values in "objGrad" and "jac"
 *    KTR_RC_EVALH  - return second derivative values in "hessian"
 *    KTR_RC_EVALH_NO_F  (this version exclude the objective term)
 *    KTR_RC_EVALHV - return a Hessian-vector product in "hessVector"
 *    KTR_RC_EVALHV_NO_F (this version exclude the objective term)
 *
 *  The argument "lambda" is not defined when requesting EVALFC or EVALGA.
 *    Usually, applications define 3 callback functions, one for EVALFC,
 *  one for EVALGA, and one for EVALH / EVALHV.  The last function
 *  evaluates H or HV depending on the value of "evalRequestCode".
 *    It is possible to combine EVALFC and EVALGA into a single function,
 *  because "x" changes only for an EVALFC request.  This is advantageous
 *  if the application evaluates functions and their derivatives at the same
 *  time.  Pass the same callback function in KTR_set_func_callback
 *  and KTR_set_grad_callback, have it populate "obj", "c", "objGrad",
 *  and "jac" for an EVALFC request, and do nothing for an EVALGA request.
 *    Do not combine EVALFC and EVALGA if hessopt = KTR_HESSOPT_PRODUCT_FINDIFF,
 *  because the finite difference Hessian changes x and calls EVALGA without
 *  calling EVALFC first.
 *    It is not possible to combine EVALH / EVALHV because "lambda" changes
 *  after the EVALFC call.
 *
 *  The "userParams" argument is an arbitrary pointer passed from the Knitro
 *  KTR_solve call to the callback.  It should be used to pass parameters
 *  defined and controlled by the application, or left null if not used.
 *  Knitro does not modify or dereference the "userParams" pointer.
 *
 *  For simplicity, the following callback functions all use the same
 *  "KTR_callback()" function prototype defined below.
 *
 *      KTR_set_func_callback
 *      KTR_set_grad_callback
 *      KTR_set_hess_callback
 *      KTR_set_newpoint_callback
 *      KTR_set_ms_process_callback
 *      KTR_set_mip_node_callback
 *
 *  Note that least squares algorithms uses separates callbacks and set
 *  functions, namely "KTR_lsq_callback" and functions:
 *
 *      KTR_lsq_set_res_callback
 *      KTR_lsq_set_jac_callback
 *
 *  Callbacks should return 0 if successful, a negative error code if not.
 *  Possible unsuccessful (negative) error codes for the func/grad/hess
 *  callback functions include:
 *
 *      KTR_RC_CALLBACK_ERR       (for generic callback errors)
 *      KTR_RC_EVAL_ERR           (for evaluation errors, e.g log(-1))
 *
 *  In addition, for the "func", "newpoint", "ms_process" and "mip_node"
 *  callbacks, the user may set the following return code to force Knitro
 *  to terminate based on some user-defined condition.
 *
 *      KTR_RC_USER_TERMINATION   (to use a callback routine
 *                                 for user specified termination)
 */
typedef int KTR_callback (const int             evalRequestCode,
                          const int             n,
                          const int             m,
                          const int             nnzJ,
                          const int             nnzH,
                          const double * const  x,
                          const double * const  lambda,
                                double * const  obj,
                                double * const  c,
                                double * const  objGrad,
                                double * const  jac,
                                double * const  hessian,
                                double * const  hessVector,
                                void   *        userParams);

/** Set the callback function that evaluates "obj" and "c" at x.
 *  It may also evaluate "objGrad" and "jac" if EVALFC and EVALGA are
 *  combined into a single call.
 *  Do not modify "hessian" or "hessVector".
 */
int  KNITRO_API KTR_set_func_callback (KTR_context_ptr       kc,
                                       KTR_callback * const  fnPtr);

/** Set the callback function that evaluates "objGrad" and "jac" at x.
 *  It may do nothing if EVALFC and EVALGA are combined into a single call.
 *  Do not modify "hessian" or "hessVector".
 */
int  KNITRO_API KTR_set_grad_callback (KTR_context_ptr       kc,
                                       KTR_callback * const  fnPtr);

/** Set the callback function that evaluates second derivatives at (x, lambda).
 *  If "evalRequestCode" equals KTR_RC_EVALH, then the function must
 *  return nonzeroes in "hessian".  If it equals KTR_RC_EVALHV, then the
 *  function multiplies second derivatives by "hessVector" and returns the
 *  product in "hessVector".
 *  Do not modify "obj", "c", "objGrad", or "jac".
 */
int  KNITRO_API KTR_set_hess_callback (KTR_context_ptr       kc,
                                       KTR_callback * const  fnPtr);

/** Defines the KTR_lsq_callback specific to nonlinear least-squares problems.
 *  (see callbacks definition above)
 *
 *  For simplicity, this definition is used by all call KTR_set_XXX functions
 *  used to set callbacks for nonlinear least squares. Namely:
 *      KTR_lsq_set_res_callback
 *      KTR_lsq_set_jac_callback
 *
 *  Callbacks should return 0 if successful, a negative error code if not.
 *  Possible unsuccessful (negative) error codes for the least squares
 *  callback functions include:
 *
 *      KTR_RC_CALLBACK_ERR       (for generic callback errors)
 *      KTR_RC_EVAL_ERR           (for evaluation errors, e.g log(-1))
 *
 *  In addition, the user may set the following return code to force Knitro
 *  to terminate based on some user-defined condition.
 *
 *      KTR_RC_USER_TERMINATION   (to use a callback routine
 *                                 for user specified termination)
 */
typedef int KTR_lsq_callback(const int            n,
                             const int            m,
                             const int            nnzJ,
                             const double * const x,
                                   double * const res,
                                   double * const jac,
                                   void *         userParams);

/** Set the callback function to evaluate the residuals "res" of a
 *  nonlinear least-squares problem.
 *  Do not modify "jac" in this function.
 */
int  KNITRO_API KTR_lsq_set_res_callback(KTR_context_ptr kc,
                                         KTR_lsq_callback * const fnPtr);

/** Set the callback function to evaluate the jacobian "jac" of 
 *  nonlinear least-squares residual function.
 *  Do not modify "res" in this function.
 */
int  KNITRO_API KTR_lsq_set_jac_callback(KTR_context_ptr kc,
                                         KTR_lsq_callback * const fnPtr);

/** Set the callback function that is invoked after Knitro computes a
 *  new estimate of the solution point (i.e., after every major iteration).
 *  The function should not modify any Knitro arguments.
 *  Argument "kc" is the context pointer for the current problem being
 *  solved inside Knitro (either the main single-solve problem, or a
 *  subproblem when using multi-start, Tuner, etc.).
 *  Arguments "x" and "lambda" contain the new point and values.
 *  Arguments "obj" and "c" contain objective and constraint values at "x",
 *  and "objGrad" and "jac" contain the objective gradient and constraint
 *  Jacobian at "x".
 */
typedef int  KTR_newpt_callback (KTR_context_ptr           kc,
                                     const int             n,
                                     const int             m,
                                     const int             nnzJ,
                                     const double * const  x,
                                     const double * const  lambda,
                                     const double          obj,
                                     const double * const  c,
                                     const double * const  objGrad,
                                     const double * const  jac,
                                           void   *        userParams);
int  KNITRO_API KTR_set_newpt_callback (KTR_context_ptr             kc,
                                        KTR_newpt_callback * const  fnPtr);
/** An older version of this callback maintained for backwards compatibility.
 *  Please use the newer version defined above. */
int  KNITRO_API KTR_set_newpoint_callback (KTR_context_ptr       kc,
                                           KTR_callback * const  fnPtr);

/** This callback function is for multistart (MS) problems only.
 *  Set the callback function that is invoked after Knitro finishes
 *  processing a multistart solve.  The function should not modify any
 *  Knitro arguments.  Arguments "x" and "lambda" contain the solution from
 *  the last solve. Arguments "obj" and "c" contain objective and constraint
 *  values at "x".  First and second derivative arguments are not currently
 *  defined and should not be examined.
 */
int  KNITRO_API KTR_set_ms_process_callback (KTR_context_ptr       kc,
                                             KTR_callback * const  fnPtr);

/** This callback function is for mixed integer (MIP) problems only.
 *  Set the callback function that is invoked after Knitro finishes
 *  processing a node on the branch-and-bound tree (i.e., after a relaxed
 *  subproblem solve in the branch-and-bound procedure).
 *  The function should not modify any Knitro arguments.
 *  Arguments "x" and "lambda" contain the solution from the node solve.
 *  Arguments "obj" and "c" contain objective and constraint values at "x".
 *  First and second derivative arguments are not currently defined and
 *  should not be examined.
 */
int  KNITRO_API KTR_set_mip_node_callback (KTR_context_ptr       kc,
                                           KTR_callback * const  fnPtr);


/** Type declaration for the callback that allows applications to
 *  specify an initial point before each local solve in the multistart
 *  procedure.  On input, arguments "x" and "lambda" are the randomly
 *  generated initial points determined by Knitro, which can be overwritten
 *  by the user.  The argument "nSolveNumber" is the number of the
 *  multistart solve.  Return 0 if successful, a negative error code if not.
 *  Use KTR_set_ms_initpt_callback to set this callback function.
 */
typedef int  KTR_ms_initpt_callback (const int             nSolveNumber,
                                     const int             n,
                                     const int             m,
                                     const double * const  xLoBnds,
                                     const double * const  xUpBnds,
                                           double * const  x,
                                           double * const  lambda,
                                           void   * const  userParams);

/** Return 0 if successful, a negative error code if not.
 */
int  KNITRO_API KTR_set_ms_initpt_callback (KTR_context_ptr                 kc,
                                            KTR_ms_initpt_callback * const  fnPtr);


/** Applications can set a "put string" callback function to handle output
 *  generated by the Knitro solver.  By default Knitro prints to stdout
 *  or a file named "knitro.log", as determined by KTR_PARAM_OUTMODE.
 *  The KTR_puts function takes a "userParams" argument which is a
 *  a pointer passed directly from KTR_solve.  Note that "userParams" will
 *  be a NULL pointer until defined by an application call to KTR_new_puts
 *  or KTR_solve. Return 0 if successful, a negative error code if not.
 */
int  KNITRO_API KTR_set_puts_callback (KTR_context_ptr   kc,
                                       KTR_puts * const  fnPtr);


/* ----- Reading solution properties ----- */

/** Return the number of function evaluations requested by KTR_solve.
 *  A single request evaluates the objective and all constraint functions.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_FC_evals (const KTR_context_ptr  kc);

/** Return the number of gradient evaluations requested by KTR_solve.
 *  A single request evaluates first derivatives of the objective and
 *  all constraint functions.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_GA_evals (const KTR_context_ptr  kc);

/** Return the number of Hessian evaluations requested by KTR_solve.
 *  A single request evaluates second derivatives of the objective and
 *  all constraint functions.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_H_evals (const KTR_context_ptr  kc);

/** Return the number of Hessian-vector products requested by KTR_solve.
 *  A single request evaluates the product of the Hessian of the
 *  Lagrangian with a vector submitted by Knitro.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_HV_evals (const KTR_context_ptr  kc);

/** Return the solution status, objective, primal and dual variables.
 *  The status and objective value scalars are returned as pointers
 *  that need to be de-referenced to get their values.  The arrays
 *  "x" and "lambda" must be allocated by the user.
 *  Returns 0 if call is successful;
 *         <0 if there is an error.
 */
int  KNITRO_API KTR_get_solution (const KTR_context_ptr kc,
                                        int     * const status,
                                        double  * const obj,
                                        double  * const x,
                                        double  * const lambda);

/** Return the values of the constraint vector c(x) in "c".
 *  The array "c" must be allocated by the user.
 *  Returns 0 if call is successful;
 *         <0 if there is an error.
 */
int  KNITRO_API KTR_get_constraint_values (const KTR_context_ptr kc,
                                                 double  * const c);


/* ----- Solution properties for continuous problems only ----- */

/** Return the number of iterations made by KTR_solve.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_iters (const KTR_context_ptr  kc);

/** Return the number of conjugate gradient (CG) iterations made by
 *  KTR_solve.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_cg_iters (const KTR_context_ptr  kc);

/** Return the number of major iterations made by KTR_solve.
 *  Returns a negative number if there is a problem with kc.
 *  (DEPRECATED, BUT KEPT FOR NOW FOR BACKWARDS COMPATIBILITY)
 */
int  KNITRO_API KTR_get_number_major_iters (const KTR_context_ptr  kc);

/** Return the number of minor iterations made by KTR_solve.
 *  Returns a negative number if there is a problem with kc.
 *  (DEPRECATED, BUT KEPT FOR NOW FOR BACKWARDS COMPATIBILITY)
 */
int  KNITRO_API KTR_get_number_minor_iters (const KTR_context_ptr  kc);

/** Return the absolute feasibility error at the solution.
 *  Refer to the Knitro manual section on Termination Tests for a
 *  detailed definition of this quantity.
 *  Returns a negative number if there is a problem with kc.
 */
double  KNITRO_API KTR_get_abs_feas_error (const KTR_context_ptr  kc);

/** Return the relative feasibility error at the solution.
 *  Refer to the Knitro manual section on Termination Tests for a
 *  detailed definition of this quantity.
 *  Returns a negative number if there is a problem with kc.
 */
double  KNITRO_API KTR_get_rel_feas_error (const KTR_context_ptr  kc);

/** Return the absolute optimality error at the solution.
 *  Refer to the Knitro manual section on Termination Tests for a
 *  detailed definition of this quantity.
 *  Returns a negative number if there is a problem with kc.
 */
double  KNITRO_API KTR_get_abs_opt_error (const KTR_context_ptr  kc);

/** Return the relative optimality error at the solution.
 *  Refer to the Knitro manual section on Termination Tests for a
 *  detailed definition of this quantity.
 *  Returns a negative number if there is a problem with kc.
 */
double  KNITRO_API KTR_get_rel_opt_error (const KTR_context_ptr  kc);

/** Return the values of the objective gradient vector in "objGrad".
 *  The array "objGrad" must be allocated by the user.  It is a
 *  dense array of dimension "n" (where "n" is the number of variables
 *  in the problem).
 *  Returns 0 if call is successful;
 *         <0 if there is an error.
 */
int  KNITRO_API KTR_get_objgrad_values (const KTR_context_ptr kc,
                                              double  * const objGrad);

/** Return the values of the constraint Jacobian in "jac".
 *  The Jacobian values returned correspond to the non-zero sparse
 *  Jacobian indices provided by the user in KTR_init_problem().
 *  The array "jac" must be allocated by the user.
 *  Returns 0 if call is successful;
 *         <0 if there is an error.
 */
int  KNITRO_API KTR_get_jacobian_values (const KTR_context_ptr kc,
                                               double  * const jac);


/** Return the values of the residual Jacobian in "jac".
 *  The Jacobian values returned correspond to the non-zero sparse
 *  Jacobian indices provided by the user in KTR_lsq_init_problem().
 *  The array "jac" must be allocated by the user.
 *  Returns 0 if call is successful;
 *         <0 if there is an error.
 */
int  KNITRO_API KTR_lsq_get_jacobian_values (const KTR_context_ptr kc,
                                                   double  * const jac);


/** Return the values of the Hessian (or possibly Hessian
 *  approximation) in "hess".  This routine is currently only valid
 *  if 1 of the 2 following cases holds:
 *  1) KTR_HESSOPT_EXACT (presolver on or off), or;
 *  2) KTR_HESSOPT_BFGS or KTR_HESSOPT_SR1, but only with the
 *     Knitro presolver off (i.e. KTR_PRESOLVE_NONE).
 *
 *  In all other cases, either Knitro does not have an internal
 *  representation of the Hessian (or Hessian approximation),
 *  or the internal Hessian approximation corresponds only to
 *  the presolved problem form and may not be valid for the
 *  original problem form.  In these cases "hess" is left
 *  unmodified, and the routine has return code 1.
 *
 *  Note that in case 2 above (KTR_HESSOPT_BFGS or KTR_HESSOPT_SR1)
 *  the values returned in "hess" are the upper triangular values
 *  of the dense quasi-Newton Hessian approximation stored row-wise.
 *  There are ((n*n - n)/2 + n) such values (where "n" is the number
 *  of variables in the problem. These values may be quite different
 *  from the values of the exact Hessian.
 *
 *  When KTR_HESSOPT_EXACT (case 1 above) the Hessian values
 *  returned correspond to the non-zero sparse Hessian indices
 *  provided by the user in KTR_init_problem().
 *
 *  The array "hess" must be allocated by the user.
 *  Returns 0 if call is successful;
 *          1 if "hess" was not set because Knitro does not
 *            have a valid Hessian for the model stored.
 *         <0 if there is an error.
 */
int  KNITRO_API KTR_get_hessian_values (const KTR_context_ptr kc,
                                              double  * const hess);


/* ----- Solution properties for MIP problems only ----- */

/** Return the number of nodes processed in the MIP solve.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_mip_num_nodes (const KTR_context_ptr kc);

/** Return the number of continuous subproblems processed in the
 *  MIP solve.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_mip_num_solves (const KTR_context_ptr kc);

/** Return the final absolute integrality gap in the MIP solve.
 *  Refer to the Knitro manual section on Termination Tests for
 *  a detailed definition of this quantity. Returns KTR_INFBOUND
 *  if no incumbent (i.e., integer feasible) point found.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_abs_gap (const KTR_context_ptr kc);

/** Return the final absolute integrality gap in the MIP solve.
 *  Refer to the Knitro manual section on Termination Tests for
 *  a detailed definition of this quantity.  Returns KTR_INFBOUND
 *  if no incumbent (i.e., integer feasible) point found.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_rel_gap (const KTR_context_ptr kc);

/** Return the objective value of the MIP incumbent solution.
 *  Returns KTR_INFBOUND if no incumbent (i.e., integer feasible)
 *  point found.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_incumbent_obj (const KTR_context_ptr kc);

/** Return the value of the current MIP relaxation bound.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_relaxation_bnd (const KTR_context_ptr kc);

/** Return the objective value of the most recently solved MIP
 *  node subproblem.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_lastnode_obj (const KTR_context_ptr kc);

/** Return the MIP incumbent solution in "x" if one exists.
 *  Returns 1 if incumbent solution exists and call is successful;
 *          0 if no incumbent (i.e., integer feasible) exists
 *              and leaves "x" unmodified;
 *         <0 if there is an error.
 */
int  KNITRO_API KTR_get_mip_incumbent_x (const KTR_context_ptr kc,
                                         double * const x);

/* ----- Checking derivatives ----- */

/** NOTE: THIS FUNCTION IS DEPRECATED.  PLEASE USE THE "DERIVCHECK"
 *        USER OPTION FOR CHECKING DERIVATIVES.
 *
 *  Compare the application's analytic first derivatives to a finite
 *  difference approximation at x.  The objective and all constraint
 *  functions are checked.  Like KTR_solve, the routine may be used in
 *  reverse communications or callback mode (see examples/C/checkDersExample.c).
 *
 *  Returns one of the status codes KTR_RC_* (see definitions in this file).
 *  In particular:
 *    <0 - error
 *     0 - routine is finished
 *     1 - call routine again (reverse comm) with obj and c containing
 *         the objective and constraints evaluated at x
 *     2 - call routine again (reverse comm) with objGrad and jac containing
 *         the objective and constraint first derivatives evaluated at x
 *
 *  Description of the arguments:
 *    x                - input  (length n) point at which to check derivatives
 *                       output            point at which to evaluate obj and c
 *    finiteDiffMethod - 1 = forward differences, 2 = central differences
 *    absThreshold     - print when |estimate - analytic| > threshold
 *    relThreshold     - print when |estimate - analytic| > threshold * scale
 *                         where scale = max{1, |analytic|}
 *    evalStatus       - input            evaluation status (0=OK)
 *    obj              - input            objective at x
 *    c                - input (length m) constraints at x
 *    objGrad          - input (length n) analytic gradient at x
 *    jac              - input (length nnzJ) analytic constraint Jacobian at x
 *    userParams       - input  passed directly to application callback
 */
int  KNITRO_API KTR_check_first_ders (const KTR_context_ptr  kc,
                                            double * const   x,
                                      const int              finiteDiffMethod,
                                      const double           absThreshold,
                                      const double           relThreshold,
                                      const int              evalStatus,
                                      const double           obj,
                                      const double * const   c,
                                      const double * const   objGrad,
                                      const double * const   jac,
                                            void   *         userParams);


/*------------------------------------------------------------------*/
/*     DEFINES                                                      */
/*------------------------------------------------------------------*/

/** Any numbers greater than or equal to KTR_INFBOUND in magnitude
 *  are treated as infinite by Knitro.
 */
#define KTR_INFBOUND 1.0e20

/** Possible parameter types.
 */
#define KTR_PARAMTYPE_INTEGER 0
#define KTR_PARAMTYPE_FLOAT   1
#define KTR_PARAMTYPE_STRING  2

/** Possible objective goals for the solver (objGoal in KTR_init_problem).
 */
#define KTR_OBJGOAL_MINIMIZE    0
#define KTR_OBJGOAL_MAXIMIZE    1

/** Possible values for the objective type (objType in KTR_init_problem).
 */
#define KTR_OBJTYPE_CONSTANT  -1    
#define KTR_OBJTYPE_GENERAL    0
#define KTR_OBJTYPE_LINEAR     1
#define KTR_OBJTYPE_QUADRATIC  2

/** Possible values for the constraint type (cType in KTR_init_problem).
 */
#define KTR_CONTYPE_GENERAL    0
#define KTR_CONTYPE_LINEAR     1
#define KTR_CONTYPE_QUADRATIC  2

/** Possible values for the residual type (rType in KTR_lsq_init_problem).
 */
#define KTR_RESTYPE_GENERAL    0
#define KTR_RESTYPE_LINEAR     1

/** Possible values for the variable type (xType in KTR_mip_init_problem).
 */
#define KTR_VARTYPE_CONTINUOUS  0
#define KTR_VARTYPE_INTEGER     1
#define KTR_VARTYPE_BINARY      2

/** Possible values for the objective and constraint functions (fnType
 *  in KTR_mip_init_problem).
 */
#define KTR_FNTYPE_UNCERTAIN   0
#define KTR_FNTYPE_CONVEX      1
#define KTR_FNTYPE_NONCONVEX   2

/** Possible values to indicate whether a variable appears only
 *  in linear terms in the problem.  Used by KTR_set_linearvars
 *  function.
 */
#define KTR_LINEARVAR_NO      0 /*-- NONLINEAR OR UNKNOWN */
#define KTR_LINEARVAR_YES     1 /*-- LINEAR ONLY EVERYWHERE */

/** Return codes used by Knitro for reverse communication.
 */
#define KTR_RC_BEGINEND        0
#define KTR_RC_EVALFC          1
#define KTR_RC_EVALGA          2
#define KTR_RC_EVALH           3
#define KTR_RC_EVALX0          4  /*-- FOR INTERNAL USE, Knitro 5.x */
#define KTR_RC_FINISHED        5  /*-- FOR INTERNAL USE, Knitro 5.x */
#define KTR_RC_NEWPOINT        6
#define KTR_RC_EVALHV          7
#define KTR_RC_EVALH_NO_F      8  /*-- NO OBJECTIVE COMPONENT INCLUDED */
#define KTR_RC_EVALHV_NO_F     9  /*-- NO OBJECTIVE COMPONENT INCLUDED */
/** Additional codes defined for callbacks using KTR_callback.
 */
#define KTR_RC_NODE           10  /*-- DEFINED FOR MIP NODE CALLBACK */
#define KTR_RC_MSPROCESS      11  /*-- DEFINED FOR MS PROCESS CALLBACK */

/** Return codes when Knitro terminates.
 */
#define KTR_RC_OPTIMAL_OR_SATISFACTORY 0   /*-- OPTIMAL CODE */    
#define KTR_RC_OPTIMAL                 0   /*-- DEPRECATED OPTIMAL CODE */
#define KTR_RC_NEAR_OPT               -100 /*-- FEASIBLE CODES */
#define KTR_RC_FEAS_XTOL              -101
#define KTR_RC_FEAS_NO_IMPROVE        -102
#define KTR_RC_FEAS_FTOL              -103
#define KTR_RC_INFEASIBLE             -200 /*-- INFEASIBLE CODES */
#define KTR_RC_INFEAS_XTOL            -201
#define KTR_RC_INFEAS_NO_IMPROVE      -202
#define KTR_RC_INFEAS_MULTISTART      -203
#define KTR_RC_INFEAS_CON_BOUNDS      -204
#define KTR_RC_INFEAS_VAR_BOUNDS      -205
#define KTR_RC_UNBOUNDED              -300 /*-- UNBOUNDED CODE */
#define KTR_RC_ITER_LIMIT_FEAS        -400 /*-- LIMIT EXCEEDED CODES (FEASIBLE) */
#define KTR_RC_ITER_LIMIT             -400 /*-- DEPRECATED - Use ITER_LIMIT_(IN)FEAS */
#define KTR_RC_TIME_LIMIT_FEAS        -401
#define KTR_RC_TIME_LIMIT             -401 /*-- DEPRECATED - Use TIME_LIMIT_(IN)FEAS */
#define KTR_RC_FEVAL_LIMIT_FEAS       -402
#define KTR_RC_MIP_EXH_FEAS           -403
#define KTR_RC_MIP_EXH                -403 /*-- DEPRECATED - Use MIP_EXH_(IN)FEAS */
#define KTR_RC_MIP_TERM_FEAS          -404
#define KTR_RC_MIP_FEAS_TERM          -404 /*-- DEPRECATED - Use MIP_TERM_FEAS */
#define KTR_RC_MIP_SOLVE_LIMIT_FEAS   -405
#define KTR_RC_MIP_SOLVE_LIMIT        -405 /*-- DEPRECATED - Use MIP_SOLVE_LIMIT_(IN)FEAS */
#define KTR_RC_MIP_NODE_LIMIT_FEAS    -406
#define KTR_RC_MIP_NODE_LIMIT         -406 /*-- DEPRECATED - Use MIP_NODE_LIMIT_(IN)FEAS */
#define KTR_RC_ITER_LIMIT_INFEAS      -410 /*-- LIMIT EXCEEDED CODES (INFEASIBLE) */
#define KTR_RC_TIME_LIMIT_INFEAS      -411
#define KTR_RC_FEVAL_LIMIT_INFEAS     -412    
#define KTR_RC_MIP_EXH_INFEAS         -413
#define KTR_RC_MIP_SOLVE_LIMIT_INFEAS -415
#define KTR_RC_MIP_NODE_LIMIT_INFEAS  -416
#define KTR_RC_CALLBACK_ERR           -500 /*-- OTHER FAILURES */
#define KTR_RC_LP_SOLVER_ERR          -501
#define KTR_RC_EVAL_ERR               -502
#define KTR_RC_OUT_OF_MEMORY          -503
#define KTR_RC_USER_TERMINATION       -504
#define KTR_RC_OPEN_FILE_ERR          -505
#define KTR_RC_BAD_N_OR_F             -506 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_CONSTRAINT         -507 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_JACOBIAN           -508 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_HESSIAN            -509 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_CON_INDEX          -510 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_JAC_INDEX          -511 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_HESS_INDEX         -512 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_CON_BOUNDS         -513 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_VAR_BOUNDS         -514 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_ILLEGAL_CALL           -515 /*-- KNITRO CALL IS OUT OF SEQUENCE */
#define KTR_RC_BAD_KCPTR              -516 /*-- KNITRO PASSED A BAD KC POINTER */
#define KTR_RC_NULL_POINTER           -517 /*-- KNITRO PASSED A NULL ARGUMENT */
#define KTR_RC_BAD_INIT_VALUE         -518 /*-- APPLICATION INITIAL POINT IS BAD */
#define KTR_RC_NEWPOINT_HALT          -519 /*-- APPLICATION TOLD KNITRO TO HALT */
#define KTR_RC_BAD_LICENSE            -520 /*-- LICENSE CHECK FAILED */
#define KTR_RC_BAD_PARAMINPUT         -521 /*-- INVALID USER OPTION DETECTED */
#define KTR_RC_LINEAR_SOLVER_ERR      -522 /*-- ERROR IN LINEAR SOLVER */
#define KTR_RC_DERIV_CHECK_FAILED     -523 /*-- DERIVATIVE CHECK FAILED */
#define KTR_RC_DERIV_CHECK_TERMINATE  -524 /*-- DERIVATIVE CHECK TERMINATE */
#define KTR_RC_OVERFLOW_ERR           -525 /*-- INTEGER OVERFLOW ERROR */   
#define KTR_RC_INTERNAL_ERROR         -600 /*-- CONTACT info@ziena.com */

/** Parameter IDs used in functions KTR_get_xxx_param and KTR_set_xxx_param.
 *  In some cases, parameter values are defined underneath the parameter ID.
 */
#define KTR_PARAM_NEWPOINT             1001
#  define KTR_NEWPOINT_NONE               0
#  define KTR_NEWPOINT_SAVEONE            1
#  define KTR_NEWPOINT_SAVEALL            2
#  define KTR_NEWPOINT_USER               3
#define KTR_PARAM_HONORBNDS            1002
#  define KTR_HONORBNDS_NO                0
#  define KTR_HONORBNDS_ALWAYS            1
#  define KTR_HONORBNDS_INITPT            2
#define KTR_PARAM_ALGORITHM            1003
#define KTR_PARAM_ALG                  1003
#  define KTR_ALG_AUTOMATIC               0
#  define KTR_ALG_AUTO                    0
#  define KTR_ALG_BAR_DIRECT              1
#  define KTR_ALG_BAR_CG                  2
#  define KTR_ALG_ACT_CG                  3
#  define KTR_ALG_IPDIRECT                1  /*-- DEPRECATED -- Please use the new  */
#  define KTR_ALG_IPCG                    2  /*-- DEPRECATED -- option names listed */
#  define KTR_ALG_ACTIVE                  3  /*-- DEPRECATED -- just above.         */
#  define KTR_ALG_ACT_SQP                 4
#  define KTR_ALG_MULTI                   5
#define KTR_PARAM_BAR_MURULE           1004
#define KTR_PARAM_BARRULE              1004  /*-- DEPRECATED -- Use BAR_MURULE */
#  define KTR_BAR_MURULE_AUTOMATIC        0
#  define KTR_BAR_MURULE_AUTO             0
#  define KTR_BAR_MURULE_MONOTONE         1
#  define KTR_BAR_MURULE_ADAPTIVE         2
#  define KTR_BAR_MURULE_PROBING          3
#  define KTR_BAR_MURULE_DAMPMPC          4
#  define KTR_BAR_MURULE_FULLMPC          5
#  define KTR_BAR_MURULE_QUALITY          6
#define KTR_PARAM_BAR_FEASIBLE         1006
#define KTR_PARAM_FEASIBLE             1006 /*-- DEPRECATED -- Use BAR_FEASIBLE */
#  define KTR_BAR_FEASIBLE_NO             0
#  define KTR_BAR_FEASIBLE_STAY           1
#  define KTR_BAR_FEASIBLE_GET            2
#  define KTR_BAR_FEASIBLE_GET_STAY       3
#  define KTR_FEASIBLE_NO                 0 /*-- DEPRECATED -- Please use the new  */
#  define KTR_FEASIBLE_ALWAYS             1 /*-- DEPRECATED -- option names above */
#define KTR_PARAM_GRADOPT              1007
#  define KTR_GRADOPT_EXACT               1
#  define KTR_GRADOPT_FORWARD             2
#  define KTR_GRADOPT_CENTRAL             3
#  define KTR_GRADOPT_USER_FORWARD        4
#  define KTR_GRADOPT_USER_CENTRAL        5
#define KTR_PARAM_HESSOPT              1008
#  define KTR_HESSOPT_EXACT               1
#  define KTR_HESSOPT_BFGS                2
#  define KTR_HESSOPT_SR1                 3
#  define KTR_HESSOPT_FINITE_DIFF         4 /*-- DEPRECATED -- Use PRODUCT_FINDIFF */
#  define KTR_HESSOPT_PRODUCT_FINDIFF     4    
#  define KTR_HESSOPT_PRODUCT             5
#  define KTR_HESSOPT_LBFGS               6
#  define KTR_HESSOPT_GAUSS_NEWTON        7 
#define KTR_PARAM_BAR_INITPT           1009
#  define KTR_BAR_INITPT_AUTO             0
#  define KTR_BAR_INITPT_YES              1 /*-- DEPRECATED -- Use STRAT1  */
#  define KTR_BAR_INITPT_STRAT1           1
#  define KTR_BAR_INITPT_NO               2 /*-- DEPRECATED -- Use STRAT2  */
#  define KTR_BAR_INITPT_STRAT2           2
#  define KTR_BAR_INITPT_STRAT3           3
#define KTR_PARAM_ACT_LPSOLVER         1012
#  define KTR_ACT_LPSOLVER_INTERNAL       1
#  define KTR_ACT_LPSOLVER_CPLEX          2
#  define KTR_ACT_LPSOLVER_XPRESS         3    
#define KTR_PARAM_LPSOLVER             1012 /*-- DEPRECATED -- USE ABOVE */
#  define KTR_LP_INTERNAL                 1
#  define KTR_LP_CPLEX                    2
#  define KTR_LP_XPRESS                   3
#define KTR_PARAM_CG_MAXIT             1013 
#define KTR_PARAM_MAXCGIT              1013 /*-- DEPRECATED -- USE ABOVE */
#define KTR_PARAM_MAXIT                1014
#define KTR_PARAM_OUTLEV               1015
#  define KTR_OUTLEV_NONE                 0
#  define KTR_OUTLEV_SUMMARY              1
#  define KTR_OUTLEV_MAJORIT10            2  /*-- DEPRECATED -- Use ITER_10 */
#  define KTR_OUTLEV_ITER_10              2
#  define KTR_OUTLEV_MAJORIT              3  /*-- DEPRECATED -- Use ITER */
#  define KTR_OUTLEV_ITER                 3
#  define KTR_OUTLEV_ALLIT                4  /*-- DEPRECATED -- Use ITER_VERBOSE */
#  define KTR_OUTLEV_ITER_VERBOSE         4
#  define KTR_OUTLEV_ALLIT_X              5  /*-- DEPRECATED -- Use ITER_X */
#  define KTR_OUTLEV_ITER_X               5
#  define KTR_OUTLEV_ALL                  6
#define KTR_PARAM_OUTMODE              1016
#  define KTR_OUTMODE_SCREEN              0
#  define KTR_OUTMODE_FILE                1
#  define KTR_OUTMODE_BOTH                2
#define KTR_PARAM_SCALE                1017
#  define KTR_SCALE_NEVER                 0
#  define KTR_SCALE_NO                    0    
#  define KTR_SCALE_ALLOW                 1  /*-- DEPRECATED -- Use SCALE_INTERNAL  */
#  define KTR_SCALE_USER_INTERNAL         1
#  define KTR_SCALE_USER_NONE             2    
#  define KTR_SCALE_INTERNAL              3    
#define KTR_PARAM_SHIFTINIT            1018  /*-- DEPRECATED -- Use HONORBNDS */
#define KTR_PARAM_SOC                  1019
#  define KTR_SOC_NO                      0
#  define KTR_SOC_MAYBE                   1
#  define KTR_SOC_YES                     2
#define KTR_PARAM_DELTA                1020
#define KTR_PARAM_BAR_FEASMODETOL      1021
#define KTR_PARAM_FEASMODETOL          1021  /*-- DEPRECATED -- Use BAR_FEASMODETOL */
#define KTR_PARAM_FEASTOL              1022
#define KTR_PARAM_FEASTOLABS           1023
#define KTR_PARAM_MAXTIMECPU           1024
#define KTR_PARAM_BAR_INITMU           1025
#define KTR_PARAM_MU                   1025  /*-- DEPRECATED -- Use BAR_INITMU */
#define KTR_PARAM_OBJRANGE             1026
#define KTR_PARAM_OPTTOL               1027
#define KTR_PARAM_OPTTOLABS            1028
#define KTR_PARAM_LINSOLVER_PIVOTTOL   1029
#define KTR_PARAM_PIVOT                1029  /*-- DEPRECATED -- Use LINSOLVER_PIVOTTOL */
#define KTR_PARAM_XTOL                 1030
#define KTR_PARAM_DEBUG                1031
#  define KTR_DEBUG_NONE                  0
#  define KTR_DEBUG_PROBLEM               1
#  define KTR_DEBUG_EXECUTION             2
#define KTR_PARAM_MULTISTART           1033
#define KTR_PARAM_MSENABLE             1033    
#  define KTR_MULTISTART_NO               0
#  define KTR_MULTISTART_YES              1
#define KTR_PARAM_MSMAXSOLVES          1034
#define KTR_PARAM_MSMAXBNDRANGE        1035
#define KTR_PARAM_MSMAXTIMECPU         1036
#define KTR_PARAM_MSMAXTIMEREAL        1037
#define KTR_PARAM_LMSIZE               1038
#define KTR_PARAM_BAR_MAXCROSSIT       1039
#define KTR_PARAM_MAXCROSSIT           1039  /*-- DEPRECATED -- Use BAR_MAXCROSSIT */
#define KTR_PARAM_MAXTIMEREAL          1040
#define KTR_PARAM_CG_PRECOND           1041
#  define KTR_CG_PRECOND_NONE             0
#  define KTR_CG_PRECOND_CHOL             1
#define KTR_PARAM_BLASOPTION           1042
#  define KTR_BLASOPTION_KNITRO           0
#  define KTR_BLASOPTION_INTEL            1
#  define KTR_BLASOPTION_DYNAMIC          2
#define KTR_PARAM_BAR_MAXREFACTOR      1043
#define KTR_PARAM_BAR_MAXBACKTRACK     1044  /*-- DEPRECATED -- Use LINESEARCH_MAXTRIALS */
#define KTR_PARAM_LINESEARCH_MAXTRIALS 1044    
#define KTR_PARAM_BLASOPTIONLIB        1045
#define KTR_PARAM_OUTAPPEND            1046
#  define KTR_OUTAPPEND_NO                0
#  define KTR_OUTAPPEND_YES               1
#define KTR_PARAM_OUTDIR               1047
#define KTR_PARAM_CPLEXLIB             1048
#define KTR_PARAM_BAR_PENRULE          1049
#  define KTR_BAR_PENRULE_AUTO            0
#  define KTR_BAR_PENRULE_SINGLE          1
#  define KTR_BAR_PENRULE_FLEX            2
#define KTR_PARAM_BAR_PENCONS          1050
#  define KTR_BAR_PENCONS_AUTO            0
#  define KTR_BAR_PENCONS_NONE            1
#  define KTR_BAR_PENCONS_ALL             2
#  define KTR_BAR_PENCONS_EQUALITIES      3
#  define KTR_BAR_PENCONS_INFEAS          4
#define KTR_PARAM_MSNUMTOSAVE          1051
#define KTR_PARAM_MSSAVETOL            1052
#define KTR_PARAM_PRESOLVEDEBUG        1053  /*-- FOR AMPL ONLY */
#  define KTR_PRESOLVEDBG_NONE            0
#  define KTR_PRESOLVEDBG_BASIC           1
#  define KTR_PRESOLVEDBG_VERBOSE         2
#define KTR_PARAM_MSTERMINATE          1054
#  define KTR_MSTERMINATE_MAXSOLVES       0
#  define KTR_MSTERMINATE_OPTIMAL         1
#  define KTR_MSTERMINATE_FEASIBLE        2
#  define KTR_MSTERMINATE_ANY             3
#define KTR_PARAM_MSSTARTPTRANGE       1055
#define KTR_PARAM_INFEASTOL            1056
#define KTR_PARAM_LINSOLVER            1057
#  define KTR_LINSOLVER_AUTO              0
#  define KTR_LINSOLVER_INTERNAL          1
#  define KTR_LINSOLVER_HYBRID            2
#  define KTR_LINSOLVER_DENSEQR           3
#  define KTR_LINSOLVER_MA27              4
#  define KTR_LINSOLVER_MA57              5
#  define KTR_LINSOLVER_MKLPARDISO        6
#define KTR_PARAM_BAR_DIRECTINTERVAL   1058
#define KTR_PARAM_PRESOLVE             1059
#  define KTR_PRESOLVE_NONE               0
#  define KTR_PRESOLVE_BASIC              1
#  define KTR_PRESOLVE_ADVANCED           2
#define KTR_PARAM_PRESOLVE_TOL         1060
#define KTR_PARAM_BAR_SWITCHRULE       1061
#  define KTR_BAR_SWITCHRULE_AUTO         0
#  define KTR_BAR_SWITCHRULE_NEVER        1
#  define KTR_BAR_SWITCHRULE_LEVEL1       2
#  define KTR_BAR_SWITCHRULE_LEVEL2       3
#define KTR_PARAM_HESSIAN_NO_F         1062
#  define KTR_HESSIAN_NO_F_FORBID         0
#  define KTR_HESSIAN_NO_F_ALLOW          1
#define KTR_PARAM_MA_TERMINATE         1063
#  define KTR_MA_TERMINATE_ALL            0
#  define KTR_MA_TERMINATE_OPTIMAL        1
#  define KTR_MA_TERMINATE_FEASIBLE       2
#  define KTR_MA_TERMINATE_ANY            3
#define KTR_PARAM_MA_MAXTIMECPU        1064
#define KTR_PARAM_MA_MAXTIMEREAL       1065
#define KTR_PARAM_MSSEED               1066
#define KTR_PARAM_MA_OUTSUB            1067
#  define KTR_MA_OUTSUB_NONE              0
#  define KTR_MA_OUTSUB_YES               1
#define KTR_PARAM_MS_OUTSUB            1068
#  define KTR_MS_OUTSUB_NONE              0
#  define KTR_MS_OUTSUB_YES               1
#define KTR_PARAM_XPRESSLIB            1069
#define KTR_PARAM_TUNER                1070
#  define KTR_TUNER_OFF                   0
#  define KTR_TUNER_ON                    1
#define KTR_PARAM_TUNER_OPTIONSFILE    1071
#define KTR_PARAM_TUNER_MAXTIMECPU     1072
#define KTR_PARAM_TUNER_MAXTIMEREAL    1073
#define KTR_PARAM_TUNER_OUTSUB         1074
#  define KTR_TUNER_OUTSUB_NONE           0
#  define KTR_TUNER_OUTSUB_YES            1 /*-- DEPRECATED -- Use OUTSUB_SUMMARY */
#  define KTR_TUNER_OUTSUB_SUMMARY        1
#  define KTR_TUNER_OUTSUB_ALL            2
#define KTR_PARAM_TUNER_TERMINATE      1075
#  define KTR_TUNER_TERMINATE_ALL         0
#  define KTR_TUNER_TERMINATE_OPTIMAL     1
#  define KTR_TUNER_TERMINATE_FEASIBLE    2
#  define KTR_TUNER_TERMINATE_ANY         3
#define KTR_PARAM_LINSOLVER_OOC        1076
#  define KTR_LINSOLVER_OOC_NO            0
#  define KTR_LINSOLVER_OOC_MAYBE         1
#  define KTR_LINSOLVER_OOC_YES           2
#define KTR_PARAM_BAR_RELAXCONS        1077
#  define KTR_BAR_RELAXCONS_NONE          0
#  define KTR_BAR_RELAXCONS_EQS           1
#  define KTR_BAR_RELAXCONS_INEQS         2
#  define KTR_BAR_RELAXCONS_ALL           3
#define KTR_PARAM_MSDETERMINISTIC      1078
#  define KTR_MSDETERMINISTIC_NO          0
#  define KTR_MSDETERMINISTIC_YES         1
#define KTR_PARAM_BAR_REFINEMENT       1079
#  define KTR_BAR_REFINEMENT_NO           0
#  define KTR_BAR_REFINEMENT_YES          1
#define KTR_PARAM_DERIVCHECK           1080
#  define KTR_DERIVCHECK_NONE             0
#  define KTR_DERIVCHECK_FIRST            1
#  define KTR_DERIVCHECK_SECOND           2
#  define KTR_DERIVCHECK_ALL              3
#define KTR_PARAM_DERIVCHECK_TYPE      1081
#  define KTR_DERIVCHECK_FORWARD          1
#  define KTR_DERIVCHECK_CENTRAL          2
#define KTR_PARAM_DERIVCHECK_TOL       1082
#define KTR_PARAM_LINSOLVER_INEXACT    1083 /*-- UNDOCUMENTED/EXPERIMENTAL */
#  define KTR_LINSOLVER_INEXACT_NO        0
#  define KTR_LINSOLVER_INEXACT_YES       1
#define KTR_PARAM_LINSOLVER_INEXACTTOL 1084 /*-- UNDOCUMENTED/EXPERIMENTAL */
#define KTR_PARAM_MAXFEVALS            1085
#define KTR_PARAM_FSTOPVAL             1086
#define KTR_PARAM_DATACHECK            1087    
#  define KTR_DATACHECK_NO                0
#  define KTR_DATACHECK_YES               1 
#define KTR_PARAM_DERIVCHECK_TERMINATE 1088
#  define KTR_DERIVCHECK_STOPERROR        1
#  define KTR_DERIVCHECK_STOPALWAYS       2   
#define KTR_PARAM_BAR_WATCHDOG         1089
#  define KTR_BAR_WATCHDOG_NO             0
#  define KTR_BAR_WATCHDOG_YES            1
#define KTR_PARAM_FTOL                 1090
#define KTR_PARAM_FTOL_ITERS           1091
#define KTR_PARAM_ACT_QPALG            1092
#  define KTR_ACT_QPALG_AUTO              0    
#  define KTR_ACT_QPALG_BAR_DIRECT        1
#  define KTR_ACT_QPALG_BAR_CG            2
#  define KTR_ACT_QPALG_ACT_CG            3
#define KTR_PARAM_BAR_INITPI_MPEC      1093
#define KTR_PARAM_XTOL_ITERS           1094
#define KTR_PARAM_LINESEARCH           1095
#  define KTR_LINESEARCH_AUTO             0
#  define KTR_LINESEARCH_BACKTRACK        1
#  define KTR_LINESEARCH_INTERPOLATE      2    
#define KTR_PARAM_OUT_CSVINFO          1096
#  define KTR_OUT_CSVINFO_NO              0
#  define KTR_OUT_CSVINFO_YES             1
#define KTR_PARAM_INITPENALTY          1097
#define KTR_PARAM_ACT_LPFEASTOL        1098
#define KTR_PARAM_CG_STOPTOL           1099    
#define KTR_PARAM_RESTARTS             1100
#define KTR_PARAM_RESTARTS_MAXIT       1101
#define KTR_PARAM_BAR_SLACKBOUNDPUSH   1102    
#define KTR_PARAM_CG_PMEM              1103
#define KTR_PARAM_BAR_SWITCHOBJ        1104
#  define KTR_BAR_SWITCHOBJ_NONE          0
#  define KTR_BAR_SWITCHOBJ_SCALARPROX    1
#  define KTR_BAR_SWITCHOBJ_DIAGPROX      2
    
#define KTR_PARAM_MIP_METHOD           2001
#  define KTR_MIP_METHOD_AUTO             0
#  define KTR_MIP_METHOD_BB               1
#  define KTR_MIP_METHOD_HQG              2
#  define KTR_MIP_METHOD_MISQP            3    
#define KTR_PARAM_MIP_BRANCHRULE       2002
#  define KTR_MIP_BRANCH_AUTO             0
#  define KTR_MIP_BRANCH_MOSTFRAC         1
#  define KTR_MIP_BRANCH_PSEUDOCOST       2
#  define KTR_MIP_BRANCH_STRONG           3
#define KTR_PARAM_MIP_SELECTRULE       2003
#  define KTR_MIP_SEL_AUTO                0
#  define KTR_MIP_SEL_DEPTHFIRST          1
#  define KTR_MIP_SEL_BESTBOUND           2
#  define KTR_MIP_SEL_COMBO_1             3
#define KTR_PARAM_MIP_INTGAPABS        2004
#define KTR_PARAM_MIP_INTGAPREL        2005
#define KTR_PARAM_MIP_MAXTIMECPU       2006
#define KTR_PARAM_MIP_MAXTIMEREAL      2007
#define KTR_PARAM_MIP_MAXSOLVES        2008
#define KTR_PARAM_MIP_INTEGERTOL       2009
#define KTR_PARAM_MIP_OUTLEVEL         2010
#  define KTR_MIP_OUTLEVEL_NONE           0
#  define KTR_MIP_OUTLEVEL_ITERS          1
#  define KTR_MIP_OUTLEVEL_ITERSTIME      2
#  define KTR_MIP_OUTLEVEL_ROOT           3    
#define KTR_PARAM_MIP_OUTINTERVAL      2011
#define KTR_PARAM_MIP_OUTSUB           2012
#  define KTR_MIP_OUTSUB_NONE             0
#  define KTR_MIP_OUTSUB_YES              1
#  define KTR_MIP_OUTSUB_YESPROB          2
#define KTR_PARAM_MIP_DEBUG            2013
#  define KTR_MIP_DEBUG_NONE              0
#  define KTR_MIP_DEBUG_ALL               1
#define KTR_PARAM_MIP_IMPLICATNS       2014  /*-- USE LOGICAL IMPLICATIONS */
#  define KTR_MIP_IMPLICATNS_NO           0
#  define KTR_MIP_IMPLICATNS_YES          1
#define KTR_PARAM_MIP_GUB_BRANCH       2015  /*-- BRANCH ON GENERALIZED BOUNDS */
#  define KTR_MIP_GUB_BRANCH_NO           0
#  define KTR_MIP_GUB_BRANCH_YES          1
#define KTR_PARAM_MIP_KNAPSACK         2016  /*-- KNAPSACK CUTS */
#  define KTR_MIP_KNAPSACK_NO             0  /*--   NONE */
#  define KTR_MIP_KNAPSACK_INEQ           1  /*--   ONLY FOR INEQUALITIES */
#  define KTR_MIP_KNAPSACK_INEQ_EQ        2  /*--   FOR INEQS AND EQS */
#define KTR_PARAM_MIP_ROUNDING         2017
#  define KTR_MIP_ROUND_AUTO              0
#  define KTR_MIP_ROUND_NONE              1  /*-- DO NOT ATTEMPT ROUNDING */
#  define KTR_MIP_ROUND_HEURISTIC         2  /*-- USE FAST HEURISTIC */
#  define KTR_MIP_ROUND_NLP_SOME          3  /*-- SOLVE NLP IF LIKELY TO WORK */
#  define KTR_MIP_ROUND_NLP_ALWAYS        4  /*-- SOLVE NLP ALWAYS */
#define KTR_PARAM_MIP_ROOTALG          2018
#  define KTR_MIP_ROOTALG_AUTO            0
#  define KTR_MIP_ROOTALG_BAR_DIRECT      1
#  define KTR_MIP_ROOTALG_BAR_CG          2
#  define KTR_MIP_ROOTALG_ACT_CG          3
#  define KTR_MIP_ROOTALG_ACT_SQP         4
#  define KTR_MIP_ROOTALG_MULTI           5    
#define KTR_PARAM_MIP_LPALG            2019
#  define KTR_MIP_LPALG_AUTO              0
#  define KTR_MIP_LPALG_BAR_DIRECT        1
#  define KTR_MIP_LPALG_BAR_CG            2
#  define KTR_MIP_LPALG_ACT_CG            3
#define KTR_PARAM_MIP_TERMINATE        2020
#  define KTR_MIP_TERMINATE_OPTIMAL       0
#  define KTR_MIP_TERMINATE_FEASIBLE      1
#define KTR_PARAM_MIP_MAXNODES         2021
#define KTR_PARAM_MIP_HEURISTIC        2022
#  define KTR_MIP_HEURISTIC_AUTO          0
#  define KTR_MIP_HEURISTIC_NONE          1
#  define KTR_MIP_HEURISTIC_FEASPUMP      2
#  define KTR_MIP_HEURISTIC_MPEC          3
#define KTR_PARAM_MIP_HEUR_MAXIT       2023
#define KTR_PARAM_MIP_HEUR_MAXTIMECPU  2024
#define KTR_PARAM_MIP_HEUR_MAXTIMEREAL 2025
#define KTR_PARAM_MIP_PSEUDOINIT       2026
#  define KTR_MIP_PSEUDOINIT_AUTO         0
#  define KTR_MIP_PSEUDOINIT_AVE          1
#  define KTR_MIP_PSEUDOINIT_STRONG       2
#define KTR_PARAM_MIP_STRONG_MAXIT     2027
#define KTR_PARAM_MIP_STRONG_CANDLIM   2028
#define KTR_PARAM_MIP_STRONG_LEVEL     2029
#define KTR_PARAM_MIP_INTVAR_STRATEGY  2030
#  define KTR_MIP_INTVAR_STRATEGY_NONE    0
#  define KTR_MIP_INTVAR_STRATEGY_RELAX   1
#  define KTR_MIP_INTVAR_STRATEGY_MPEC    2    
#define KTR_PARAM_MIP_RELAXABLE        2031
#  define KTR_MIP_RELAXABLE_NONE          0
#  define KTR_MIP_RELAXABLE_ALL           1
#define KTR_PARAM_MIP_NODEALG          2032
#  define KTR_MIP_NODEALG_AUTO            0
#  define KTR_MIP_NODEALG_BAR_DIRECT      1
#  define KTR_MIP_NODEALG_BAR_CG          2
#  define KTR_MIP_NODEALG_ACT_CG          3
#  define KTR_MIP_NODEALG_ACT_SQP         4
#  define KTR_MIP_NODEALG_MULTI           5
#define KTR_PARAM_MIP_HEUR_TERMINATE   2033
#  define KTR_MIP_HEUR_TERMINATE_FEASIBLE 1
#  define KTR_MIP_HEUR_TERMINATE_LIMIT    2
    
#define KTR_PARAM_PAR_NUMTHREADS       3001
#define KTR_PARAM_PAR_CONCURRENT_EVALS 3002
#  define KTR_PAR_CONCURRENT_EVALS_NO     0
#  define KTR_PAR_CONCURRENT_EVALS_YES    1
#define KTR_PARAM_PAR_BLASNUMTHREADS   3003
#define KTR_PARAM_PAR_LSNUMTHREADS     3004
#define KTR_PARAM_PAR_MSNUMTHREADS     3005
#  define KTR_PAR_MSNUMTHREADS_AUTO       0

#ifdef __cplusplus
}
#endif

#endif     /*-- KNITRO_H__ */
